"use strict";(self.webpackChunkwiki_42_mwx=self.webpackChunkwiki_42_mwx||[]).push([[4097],{8834:(a,o,e)=>{e.r(o),e.d(o,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var t=e(4848),n=e(8453);const r={sidebar_position:1},s="Draw",d={id:"rank 02/FdF/guia_fdf_pronta/src/graph/draw",title:"Draw",description:"Pixel por pixel, esse arquivo \xe9 um dos mais importantes, contendo toda a estrutura para fazer o desenho na tela.",source:"@site/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw.mdx",sourceDirName:"rank 02/FdF/guia_fdf_pronta/src/graph",slug:"/rank 02/FdF/guia_fdf_pronta/src/graph/draw",permalink:"/wiki_ft/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Graph files",permalink:"/wiki_ft/docs/category/graph-files"},next:{title:"Trace_Lines",permalink:"/wiki_ft/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw_trace_lines"}},i={},c=[{value:"Draw",id:"draw-1",level:3},{value:"Process_coords",id:"process_coords",level:3},{value:"Bresenham",id:"bresenham",level:3},{value:"Get_initial_values",id:"get_initial_values",level:3},{value:"Apply_scale_zoom",id:"apply_scale_zoom",level:3},{value:"Apply_center_of_map",id:"apply_center_of_map",level:3},{value:"Apply_shift",id:"apply_shift",level:3}];function l(a){const o={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,n.R)(),...a.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.header,{children:(0,t.jsx)(o.h1,{id:"draw",children:"Draw"})}),"\n",(0,t.jsx)(o.p,{children:"Pixel por pixel, esse arquivo \xe9 um dos mais importantes, contendo toda a estrutura para fazer o desenho na tela."}),"\n",(0,t.jsx)(o.h3,{id:"draw-1",children:"Draw"}),"\n",(0,t.jsx)(o.p,{children:"Essa fun\xe7\xe3o \xe9 responsavel por gerenciar os desenhos na tela"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-C",metastring:"draw",children:"void\tdraw(t_fdf_gen *gen_data)\n{\n    // Inicializa a struct de coordenadas, ela morre aqui.\n\tt_coords\tcoords;\n\n    // Se poss\xedvel limpa a imagem na tela\n\tclear_image(gen_data->data, gen_data->img_data);\n\tcoords.y = 0;\n    // Para cada linha processamos cada coluna\n\twhile (coords.y < gen_data->data->height)\n\t{\n\t\tcoords.x = 0;\n\t\twhile (coords.x < gen_data->data->width)\n\t\t{\n\t\t\tprocess_coords(&coords, gen_data);\n\t\t\tcoords.x++;\n\t\t}\n\t\tcoords.y++;\n\t}\n    // Finalmente utilizamos a fun\xe7\xe3o para exibir a imagem na tela de uma \xfanica vez\n\tmlx_put_image_to_window(gen_data->data->mlx_ptr, gen_data->data->win_ptr,\n\t\tgen_data->img_data->img_ptr, 0, 0);\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"process_coords",children:"Process_coords"}),"\n",(0,t.jsx)(o.p,{children:"Fun\xe7\xe3o statica responsavel por processar as coordenadas e efetuar o algoritmo de Bresehnam"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-C",metastring:"process_coords",children:"static void\tprocess_coords(t_coords *coords, t_fdf_gen *gen_data)\n{\n\tif (coords->x < gen_data->data->width - 1)\n\t{\n\t\tcoords->x1 = coords->x + 1;\n\t\tcoords->y1 = coords->y;\n\t\tbresehnam(*coords, gen_data);\n\t}\n\tif (coords->y < gen_data->data->height - 1)\n\t{\n\t\tcoords->x1 = coords->x;\n\t\tcoords->y1 = coords->y + 1;\n\t\tbresehnam(*coords, gen_data);\n\t}\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"bresenham",children:"Bresenham"}),"\n",(0,t.jsx)(o.p,{children:"Funcao que executa as funcoes auxiliares utilizando o algoritimo de Bresenham"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-c",metastring:"Bresehnam",children:"static void\tbresenham(t_coords coords, t_fdf_gen *gen_data)\n{\n\tfloat\tx_step;\n\tfloat\ty_step;\n\n\tx_step = 0;\n\ty_step = 0;\n\tcoords.z = 0;\n\tcoords.z1 = 0;\n\tcoords.start_color = 0;\n\tget_initial_values(&coords, gen_data->data);\n\tapply_scale_zoom(&coords, gen_data->graph);\n\tapply_center_of_map(&coords, gen_data);\n\tisometric(&coords.x, &coords.y, coords.z, gen_data->graph);\n\tisometric(&coords.x1, &coords.y1, coords.z1, gen_data->graph);\n\tapply_shift(&coords, gen_data->graph);\n\ttrace_lines(&x_step, &y_step, &coords, gen_data);\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"get_initial_values",children:"Get_initial_values"}),"\n",(0,t.jsx)(o.p,{children:"Funcao acessa e atribui valores iniciais de coordenadas e cores."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-c",metastring:"get_initial_values",children:"void get_initial_values(t_coords *coords, t_fdf *data)\n{\n\t// Acessa os valores z dentro dos blocos da matriz - valores iniciais\n\tcoords->z = data->z_matrix[\n\t\t(int)(coords->y * data->width + coords->x)].value;\n\t// Acesso ao valor Z (valor atual altura)\n\tcoords->z1 = data->z_matrix[\n\t\t(int)(coords->y1 * data->width + coords->x1)].value;\n\t// Acesso ao valor Z1 ( proximo valor altura)\n\tcoords->start_color = ft_atoi_hexa(data->z_matrix[\n\t\t\t(int)(coords->y * data->width + coords->x)].hex);\n\t// Acesso \xe0 cor inicial\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"apply_scale_zoom",children:"Apply_scale_zoom"}),"\n",(0,t.jsx)(o.p,{children:"Os pontos iniciais e finais foram ampliados para o dobro de sua dist\xe2ncia original, resultando em uma linha maior."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-C",metastring:"apply_scale_zoom",children:"void\tapply_scale_zoom(t_coords *coords, t_graph *graph)\n{\n\tcoords->x *= graph->zoom;\n\tcoords->y *= graph->zoom;\n\tcoords->x1 *= graph->zoom;\n\tcoords->y1 *= graph->zoom;\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"apply_center_of_map",children:"Apply_center_of_map"}),"\n",(0,t.jsx)(o.p,{children:"Ajusta as coordenadas dos pontos, aplicando o zoom de forma multiplicativa"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-C",children:"void\tapply_center_of_map(t_coords *coords, t_fdf_gen *gen_data)\n{\n\tcoords->x -= (gen_data->data->width - 1) * gen_data->graph->zoom / 2.0;\n\tcoords->y -= (gen_data->data->height - 1) * gen_data->graph->zoom / 2.0;\n\tcoords->x1 -= (gen_data->data->width - 1) * gen_data->graph->zoom / 2.0;\n\tcoords->y1 -= (gen_data->data->height - 1) * gen_data->graph->zoom / 2.0;\n}\n"})}),"\n",(0,t.jsx)(o.h3,{id:"apply_shift",children:"Apply_shift"}),"\n",(0,t.jsx)(o.p,{children:"Aplica um deslocamento (ou shift) nas coordenadas dos pontos representados pela struct coords."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-c",metastring:"apply_shift",children:"void\tapply_shift(t_coords *coords, t_graph *graph)\n{\n\tcoords->x += graph->shift_x;\n\tcoords->y += graph->shift_y;\n\tcoords->x1 += graph->shift_x;\n\tcoords->y1 += graph->shift_y;\n}\n"})})]})}function p(a={}){const{wrapper:o}={...(0,n.R)(),...a.components};return o?(0,t.jsx)(o,{...a,children:(0,t.jsx)(l,{...a})}):l(a)}},8453:(a,o,e)=>{e.d(o,{R:()=>s,x:()=>d});var t=e(6540);const n={},r=t.createContext(n);function s(a){const o=t.useContext(r);return t.useMemo((function(){return"function"==typeof a?a(o):{...o,...a}}),[o,a])}function d(a){let o;return o=a.disableParentContext?"function"==typeof a.components?a.components(n):a.components||n:s(a.components),t.createElement(r.Provider,{value:o},a.children)}}}]);