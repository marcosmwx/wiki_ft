"use strict";(self.webpackChunkwiki_42_mwx=self.webpackChunkwiki_42_mwx||[]).push([[4097],{8834:(a,r,o)=>{o.r(r),o.d(r,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>n,metadata:()=>d,toc:()=>c});var e=o(4848),t=o(8453);const n={sidebar_position:1},s="Draw",d={id:"rank 02/FdF/guia_fdf_pronta/src/graph/draw",title:"Draw",description:"Pixel por pixel, esse arquivo \xe9 um dos mais importantes, contendo toda a estrutura para fazer o desenho na tela.",source:"@site/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw.mdx",sourceDirName:"rank 02/FdF/guia_fdf_pronta/src/graph",slug:"/rank 02/FdF/guia_fdf_pronta/src/graph/draw",permalink:"/wiki_ft/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Graph files",permalink:"/wiki_ft/docs/category/graph-files"},next:{title:"Trace_Lines",permalink:"/wiki_ft/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw_trace_lines"}},i={},c=[{value:"Draw",id:"draw-1",level:3},{value:"Process_coords",id:"process_coords",level:3},{value:"Bresenham",id:"bresenham",level:3},{value:"Get_initial_values",id:"get_initial_values",level:3},{value:"Apply_scale_zoom",id:"apply_scale_zoom",level:3},{value:"Apply_center_of_map",id:"apply_center_of_map",level:3},{value:"Apply_shift",id:"apply_shift",level:3}];function l(a){const r={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...a.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(r.header,{children:(0,e.jsx)(r.h1,{id:"draw",children:"Draw"})}),"\n",(0,e.jsx)(r.p,{children:"Pixel por pixel, esse arquivo \xe9 um dos mais importantes, contendo toda a estrutura para fazer o desenho na tela."}),"\n",(0,e.jsx)(r.h3,{id:"draw-1",children:"Draw"}),"\n",(0,e.jsx)(r.p,{children:"Essa fun\xe7\xe3o \xe9 responsavel por gerenciar os desenhos na tela"}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-C",metastring:"draw",children:"void\tdraw(t_fdf_gen *gen_data)\r\n{\r\n    // Inicializa a struct de coordenadas, ela morre aqui.\r\n\tt_coords\tcoords;\r\n\r\n    // Se poss\xedvel limpa a imagem na tela\r\n\tclear_image(gen_data->data, gen_data->img_data);\r\n\tcoords.y = 0;\r\n    // Para cada linha processamos cada coluna\r\n\twhile (coords.y < gen_data->data->height)\r\n\t{\r\n\t\tcoords.x = 0;\r\n\t\twhile (coords.x < gen_data->data->width)\r\n\t\t{\r\n\t\t\tprocess_coords(&coords, gen_data);\r\n\t\t\tcoords.x++;\r\n\t\t}\r\n\t\tcoords.y++;\r\n\t}\r\n    // Finalmente utilizamos a fun\xe7\xe3o para exibir a imagem na tela de uma \xfanica vez\r\n\tmlx_put_image_to_window(gen_data->data->mlx_ptr, gen_data->data->win_ptr,\r\n\t\tgen_data->img_data->img_ptr, 0, 0);\r\n}\n"})}),"\n",(0,e.jsx)(r.h3,{id:"process_coords",children:"Process_coords"}),"\n",(0,e.jsx)(r.p,{children:"Fun\xe7\xe3o statica responsavel por processar as coordenadas e efetuar o algoritmo de Bresehnam"}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-C",metastring:"process_coords",children:"static void\tprocess_coords(t_coords *coords, t_fdf_gen *gen_data)\r\n{\r\n\tif (coords->x < gen_data->data->width - 1)\r\n\t{\r\n\t\tcoords->x1 = coords->x + 1;\r\n\t\tcoords->y1 = coords->y;\r\n\t\tbresehnam(*coords, gen_data);\r\n\t}\r\n\tif (coords->y < gen_data->data->height - 1)\r\n\t{\r\n\t\tcoords->x1 = coords->x;\r\n\t\tcoords->y1 = coords->y + 1;\r\n\t\tbresehnam(*coords, gen_data);\r\n\t}\r\n}\n"})}),"\n",(0,e.jsx)(r.h3,{id:"bresenham",children:"Bresenham"}),"\n",(0,e.jsx)(r.p,{children:"Funcao que executa as funcoes auxiliares utilizando o algoritimo de Bresenham"}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-c",metastring:"Bresehnam",children:"static void\tbresenham(t_coords coords, t_fdf_gen *gen_data)\r\n{\r\n\tfloat\tx_step;\r\n\tfloat\ty_step;\r\n\r\n\tx_step = 0;\r\n\ty_step = 0;\r\n\tcoords.z = 0;\r\n\tcoords.z1 = 0;\r\n\tcoords.start_color = 0;\r\n\tget_initial_values(&coords, gen_data->data);\r\n\tapply_scale_zoom(&coords, gen_data->graph);\r\n\tapply_center_of_map(&coords, gen_data);\r\n\tisometric(&coords.x, &coords.y, coords.z, gen_data->graph);\r\n\tisometric(&coords.x1, &coords.y1, coords.z1, gen_data->graph);\r\n\tapply_shift(&coords, gen_data->graph);\r\n\ttrace_lines(&x_step, &y_step, &coords, gen_data);\r\n}\n"})}),"\n",(0,e.jsx)(r.h3,{id:"get_initial_values",children:"Get_initial_values"}),"\n",(0,e.jsx)(r.p,{children:"Funcao acessa e atribui valores iniciais de coordenadas e cores."}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-c",metastring:"get_initial_values",children:"void get_initial_values(t_coords *coords, t_fdf *data)\r\n{\r\n\t// Acessa os valores z dentro dos blocos da matriz - valores iniciais\r\n\tcoords->z = data->z_matrix[\r\n\t\t(int)(coords->y * data->width + coords->x)].value;\r\n\t// Acesso ao valor Z (valor atual altura)\r\n\tcoords->z1 = data->z_matrix[\r\n\t\t(int)(coords->y1 * data->width + coords->x1)].value;\r\n\t// Acesso ao valor Z1 ( proximo valor altura)\r\n\tcoords->start_color = ft_atoi_hexa(data->z_matrix[\r\n\t\t\t(int)(coords->y * data->width + coords->x)].hex);\r\n\t// Acesso \xe0 cor inicial\r\n}\n"})}),"\n",(0,e.jsx)(r.h3,{id:"apply_scale_zoom",children:"Apply_scale_zoom"}),"\n",(0,e.jsx)(r.p,{children:"Os pontos iniciais e finais foram ampliados para o dobro de sua dist\xe2ncia original, resultando em uma linha maior."}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-C",metastring:"apply_scale_zoom",children:"void\tapply_scale_zoom(t_coords *coords, t_graph *graph)\r\n{\r\n\tcoords->x *= graph->zoom;\r\n\tcoords->y *= graph->zoom;\r\n\tcoords->x1 *= graph->zoom;\r\n\tcoords->y1 *= graph->zoom;\r\n}\n"})}),"\n",(0,e.jsx)(r.h3,{id:"apply_center_of_map",children:"Apply_center_of_map"}),"\n",(0,e.jsx)(r.p,{children:"Ajusta as coordenadas dos pontos, aplicando o zoom de forma multiplicativa"}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-C",children:"void\tapply_center_of_map(t_coords *coords, t_fdf_gen *gen_data)\r\n{\r\n\tcoords->x -= (gen_data->data->width - 1) * gen_data->graph->zoom / 2.0;\r\n\tcoords->y -= (gen_data->data->height - 1) * gen_data->graph->zoom / 2.0;\r\n\tcoords->x1 -= (gen_data->data->width - 1) * gen_data->graph->zoom / 2.0;\r\n\tcoords->y1 -= (gen_data->data->height - 1) * gen_data->graph->zoom / 2.0;\r\n}\n"})}),"\n",(0,e.jsx)(r.h3,{id:"apply_shift",children:"Apply_shift"}),"\n",(0,e.jsx)(r.p,{children:"Aplica um deslocamento (ou shift) nas coordenadas dos pontos representados pela struct coords."}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-c",metastring:"apply_shift",children:"void\tapply_shift(t_coords *coords, t_graph *graph)\r\n{\r\n\tcoords->x += graph->shift_x;\r\n\tcoords->y += graph->shift_y;\r\n\tcoords->x1 += graph->shift_x;\r\n\tcoords->y1 += graph->shift_y;\r\n}\n"})})]})}function p(a={}){const{wrapper:r}={...(0,t.R)(),...a.components};return r?(0,e.jsx)(r,{...a,children:(0,e.jsx)(l,{...a})}):l(a)}},8453:(a,r,o)=>{o.d(r,{R:()=>s,x:()=>d});var e=o(6540);const t={},n=e.createContext(t);function s(a){const r=e.useContext(n);return e.useMemo((function(){return"function"==typeof a?a(r):{...r,...a}}),[r,a])}function d(a){let r;return r=a.disableParentContext?"function"==typeof a.components?a.components(t):a.components||t:s(a.components),e.createElement(n.Provider,{value:r},a.children)}}}]);