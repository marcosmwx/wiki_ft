"use strict";(self.webpackChunkwiki_42_mwx=self.webpackChunkwiki_42_mwx||[]).push([[6],{7852:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var n=t(4848),r=t(8453);const s={sidebar_position:2},i="Trace_Lines",o={id:"rank 02/FdF/guia_fdf_pronta/src/graph/draw_trace_lines",title:"Trace_Lines",description:"Arquivos utilitarios da brasenham",source:"@site/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw_trace_lines.mdx",sourceDirName:"rank 02/FdF/guia_fdf_pronta/src/graph",slug:"/rank 02/FdF/guia_fdf_pronta/src/graph/draw_trace_lines",permalink:"/wiki_ft/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw_trace_lines",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw_trace_lines.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Draw",permalink:"/wiki_ft/docs/rank 02/FdF/guia_fdf_pronta/src/graph/draw"},next:{title:"Isometric",permalink:"/wiki_ft/docs/rank 02/FdF/guia_fdf_pronta/src/graph/isometric"}},d={},c=[{value:"Trace_lines",id:"trace_lines-1",level:3},{value:"Set_pixel",id:"set_pixel",level:3}];function l(e){const a={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"trace_lines",children:"Trace_Lines"})}),"\n",(0,n.jsx)(a.p,{children:"Arquivos utilitarios da brasenham"}),"\n",(0,n.jsx)(a.h3,{id:"trace_lines-1",children:"Trace_lines"}),"\n",(0,n.jsx)(a.p,{children:'Desenha uma linha entre dois pontos no espa\xe7o 2D, calcula passos necessarios para "trilhar" a linha'}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-c",children:"void\ttrace_lines(float *x_step, float *y_step,\n\t\tt_coords *coords, t_fdf_gen *gen_data)\n{\n\tint\t\tmax;\n\n\tmax = 0;\n// calcula passos em x e y\n\t*x_step = coords->x1 - coords->x;\n\t*y_step = coords->y1 - coords->y;\n// Calcula o maior valor entre os passos em X e Y\n\tmax = max_func(mod(*x_step), mod(*y_step));\n// Normaliza o passo em X e Y para que haja algum tipo de constancia na magnetude\n\t*x_step /= max;\n\t*y_step /= max;\n\twhile ((int)(coords->x - coords->x1) || (int)(coords->y - coords->y1))\n\t{\n\t\tset_pixel(coords, gen_data); // Define o pixel atual\n\t\tcoords->x += *x_step; // Atualiza a coordenada X\n\t\tcoords->y += *y_step; // Atualiza a coordenada Y\n\t}\n}\n"})}),"\n",(0,n.jsx)(a.h3,{id:"set_pixel",children:"Set_pixel"}),"\n",(0,n.jsx)(a.p,{children:"Define a cor de um pixel especifico na imagem que esta sendo gerada"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-c",metastring:"set_pixel",children:"static void\tset_pixel(t_coords *coords, t_fdf_gen *gen_data)\n{\n\tint\tindex;\n\n\tindex = 0;\n// Verifica se as coordenadas (coords->x, coords->y) est\xe3o dentro dos limites da janela\n\tif (coords->x >= 0 && coords->x < gen_data->data->win_width\n\t\t&& coords->y >= 0 && coords->y < gen_data->data->win_height)\n\t{\n// Calcula o \xedndice do pixel na mem\xf3ria da imagem (nao da para simplesmente pintar ali.. tem que achar na memoria da imagem)\n\t\tindex = ((int)coords->y * gen_data->img_data->size_line\n\t\t\t\t+ (int)coords->x * (gen_data->img_data->bpp / 8));\n// Define a cor do pixel no \xedndice calculado\n\t\t*(int *)(gen_data->img_data->img_data + index) = coords->start_color;\n\t}\n}\n"})})]})}function p(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>i,x:()=>o});var n=t(6540);const r={},s=n.createContext(r);function i(e){const a=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:a},e.children)}}}]);