---
sidebar_position: 2
---

# push_swap ðŸ§ ðŸ“¦

## âœ¨ IntroduÃ§Ã£o ao Radix Sort

O **Radix Sort** Ã© um algoritmo de ordenaÃ§Ã£o nÃ£o comparativo que organiza os nÃºmeros a partir dos seus dÃ­gitos, da menor casa (menos significativa) atÃ© a maior. No contexto do `push_swap`, ele Ã© usado para ordenar eficientemente pilhas grandes, minimizando o nÃºmero de operaÃ§Ãµes. O algoritmo Ã© ideal para este projeto, pois oferece uma complexidade de tempo linear em muitos casos prÃ¡ticos â€” `O(n * k)` onde `n` Ã© o nÃºmero de elementos e `k` o nÃºmero de dÃ­gitos no maior nÃºmero.

## ðŸ—‚ï¸ O que faz o arquivo `push_swap.c`?

O arquivo `push_swap.c` Ã© o ponto de entrada da aplicaÃ§Ã£o. Ele Ã© responsÃ¡vel por:

- Validar os argumentos passados na linha de comando.
- Criar as pilhas `a` e `b`.
- Iniciar o processo de ordenaÃ§Ã£o com base no tamanho da pilha.
- Selecionar o algoritmo de ordenaÃ§Ã£o apropriado (`sort_three`, `sort_four`, `sort_five`, ou `radix_sort`).
- Gerenciar a liberaÃ§Ã£o de memÃ³ria.

---

## ðŸ§¾ CÃ³digo completo: `push_swap.c`

```c
static int	get_min_index(t_node *stack)
{
	int	index;
	int	i;
	int	min;

	min = stack->value;
	i = 0;
	index = 0;
	while (stack)
	{
		if (stack->value < min)
		{
			min = stack->value;
			index = i;
		}
		stack = stack->next;
		i++;
	}
	return (index);
}

static void	sort_four(t_node **a, t_node **b)
{
	int min_index;

	min_index = get_min_index(*a);
	while (min_index > 0)
	{
		if (min_index <= 2)
			ra(a);
		else
			rra(a);
		min_index = get_min_index(*a);
	}
	pb(a, b);
	sort_three(a);
	pa(a, b);
}

static void	sort_five(t_node **a, t_node **b)
{
	int min_index;

	while (stack_size(*a) > 3)
	{
		min_index = get_min_index(*a);
		while (min_index > 0)
		{
			if (min_index <= stack_size(*a) / 2)
				ra(a);
			else
				rra(a);
			min_index = get_min_index(*a);
		}
		pb(a, b);
	}
	sort_three(a);
	while (*b)
		pa(a, b);
}

static int is_sorted(t_node *stack)
{
    while (stack && stack->next)
    {
        if (stack->value > stack->next->value)
            return (0);
        stack = stack->next;
    }
    return (1);
}

static void do_sort(t_node **a, t_node **b)
{
	if (!is_sorted(*a))
	{
		if (stack_size(*a) == 2 && (*a)->value > (*a)->next->value)
			sa(a);
		else if (stack_size(*a) == 3)
			sort_three(a);
		else if (stack_size(*a) == 4)
			sort_four(a, b);
		else if (stack_size(*a) == 5)
			sort_five(a, b);
		else
		{
			assign_indexes(*a);
			radix_sort(a, b);
		}
	}
	free_stack(a);
	free_stack(b);
}

int	main(int argc, char **argv)
{
	t_node		*a = NULL;
	t_node		*b = NULL;
	long long	*numbers_list;
	int			count;
	int			i;

	count = 0;
	i = -1;
	if (argc < 2)
	{
		write(2, "Error\n", 6);
		return (0);
	}
	numbers_list = verify_arguments(argc, argv, &count);
	if (!numbers_list)
	{
		write(2, "Error\n", 6);
		return (0);
	}
	while (++i < count)
		ft_add_last(&a, (int)numbers_list[i]);
	do_sort(&a, &b);
	free(numbers_list);
	return (0);
}
```

## ðŸ§  ExplicaÃ§Ã£o Detalhada

### ðŸ§© get_min_index

Essa funÃ§Ã£o percorre a pilha e retorna o Ã­ndice do menor valor. Ã‰ Ãºtil para saber qual elemento deve ser movido primeiro em ordenaÃ§Ãµes pequenas.


### ðŸ”¢ sort_four e sort_five

FunÃ§Ãµes especÃ­ficas para ordenar 4 e 5 elementos. A lÃ³gica Ã©:

    Encontrar o menor elemento e movÃª-lo para a pilha b.

    Ordenar os elementos restantes com sort_three.

    Trazer o menor de volta para a.

### âœ… is_sorted

Verifica se a pilha jÃ¡ estÃ¡ ordenada em ordem crescente. Se sim, evita realizar operaÃ§Ãµes desnecessÃ¡rias.
ðŸ§® do_sort

Seleciona qual algoritmo aplicar com base na quantidade de elementos:

    2 elementos: swap direto com sa.

    3 a 5 elementos: ordenaÃ§Ãµes especÃ­ficas com lÃ³gica baseada em ra, rra, pb, pa.

    Mais de 5 elementos: converte os valores em Ã­ndices e aplica o Radix Sort.

AlÃ©m disso, garante liberaÃ§Ã£o da memÃ³ria apÃ³s a ordenaÃ§Ã£o.
### ðŸ§± main

    Verifica se hÃ¡ argumentos suficientes.

    Valida e converte os argumentos para inteiros.

    Cria a pilha a.

    Chama do_sort para iniciar a ordenaÃ§Ã£o.

    Libera os recursos usados.