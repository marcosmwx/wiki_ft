---
sidebar_position: 5
---

# ğŸ“¦ radix_sort.c
Entendendo a lÃ³gica passo a passo

## ğŸ¯ Objetivo do arquivo
Esse arquivo implementa o algoritmo Radix Sort para ordenar os elementos de uma pilha (stack a) usando operaÃ§Ãµes restritas do projeto push_swap.

## ğŸ§  O que Ã© Radix Sort?
Radix Sort Ã© um algoritmo de ordenaÃ§Ã£o que nÃ£o compara valores diretamente.

Ele ordena os elementos com base na representaÃ§Ã£o binÃ¡ria (ou decimal) de cada nÃºmero, bit a bit (ou dÃ­gito a dÃ­gito), do menos significativo para o mais significativo.
- Ã‰ como organizar nÃºmeros por cada casa decimal, mas aqui usamos bits (0s e 1s).

## ğŸ” Exemplo prÃ¡tico:
Imagine que temos os Ã­ndices (jÃ¡ atribuÃ­dos anteriormente) na stack:

```mdxjs
Stack A (valores):     [12, 5, 3, 8]
Stack A (Ã­ndices):     [3, 1, 0, 2]  â¬…ï¸ pois Ã© a ordem crescente dos valores

RepresentaÃ§Ã£o binÃ¡ria:
3 = 011
1 = 001
0 = 000
2 = 010
```

Cada nÃºmero tem 3 bits. EntÃ£o o Radix Sort vai realizar 3 passes:

## ğŸ§© Fase 1 â€” Bit 0 (menos significativo):

```mdxjs
Verifica o bit 0 (direita):

011 â†’ 1
001 â†’ 1
000 â†’ 0
010 â†’ 0
```
```mdxjs
Dividimos os elementos:

    bit = 0: mandamos para stack B â†’ pb

    bit = 1: rotacionamos em A â†’ ra
```
```mdxjs
Resultado:

Stack A: [3, 1]  â¬…ï¸ ainda nÃ£o ordenado, mas com bit 1
Stack B: [0, 2]  â¬…ï¸ bit 0
```
```mdxjs
Depois voltamos todos da B â†’ A com pa.
ğŸ”„ Fase 2 â€” Bit 1:
```

Agora olhamos o segundo bit da direita.

Repetimos o processo. Assim, cada vez mais os elementos se aproximam da ordem correta.
No fim das 3 fases (porque temos atÃ© 3 bits), a pilha estarÃ¡ ordenada por Ã­ndices, ou seja, ordenada pelos valores originais.

## ğŸ› ï¸ Explicando o CÃ³digo
### ğŸ”¹ get_max_bits

```C
static int get_max_bits(t_node *stack)
```

Essa funÃ§Ã£o calcula quantos bits sÃ£o necessÃ¡rios para representar o maior Ã­ndice da pilha.
```mdxjs
Exemplo:
Se o maior Ã­ndice Ã© 6
â†’ 6 em binÃ¡rio Ã© 110
â†’ precisa de 3 bits
```

```C
while ((max_index >> bits) != 0)
bits++;
```

Aqui usamos o operador de bit shift (>>) para ir deslocando os bits atÃ© sobrar 0, contando quantos bits foram usados.

### ğŸ”¹ radix_sort

```C
void radix_sort(t_node **a, t_node **b)
```

Essa funÃ§Ã£o executa o Radix Sort real, com base nos bits:

ğŸ”„ Loop externo:

```C
while (i < max_bits)
```

â†’ repete para cada bit (0, 1, 2, ...)

ğŸ” Loop interno:
```C
while (j < size)
```
â†’ para cada elemento da pilha, analisamos o bit i atual com:

```C
if (((*a)->index >> i) & 1)
```
*`>> i`: desloca os bits para a direita i vezes.*

*`& 1`: verifica se o bit atual Ã© 1.*

- Se for 1: fazemos ra (rotate a) â†’ mantemos em A.
- Se for 0: fazemos pb (push para B) â†’ mandamos para a "espera".

ğŸ”š No fim de cada fase:
```C
while (*b)
pa(a, b);
```

Recolocamos tudo de volta da stack B para A, prontos para o prÃ³ximo bit.

### ğŸ¯ Por que usar bits?
âœ… Vantagens:

- Ã‰ determinÃ­stico e estÃ¡vel.
- Funciona muito bem quando os nÃºmeros sÃ£o pequenos e sequenciais (como os Ã­ndices que jÃ¡ criamos).
- Evita comparaÃ§Ãµes e facilita muito dentro das restriÃ§Ãµes do push_swap (que sÃ³ permite algumas operaÃ§Ãµes).

### ğŸ”š ConclusÃ£o
| Conceito         | FunÃ§Ã£o                                                                 |
|------------------|------------------------------------------------------------------------|
| **Bit manipulation** | Usada para isolar cada bit individual e decidir o que fazer com o nÃºmero. |
| **Stack A e B**       | A: principal. B: temporÃ¡ria para segregar elementos.                    |
| **Ãndice**            | JÃ¡ estÃ¡ atribuÃ­do com base na ordem dos valores, e o Radix ordena com base nisso. |
| **Complexidade**      | `O(n * log n)` nos melhores casos com Ã­ndices â€” muito bom para nosso cenÃ¡rio. |
