---
sidebar_position: 9
---

# üìú Script

## Script para log de informa√ß√µes

:::warning[Se Liga]
Esta √© uma parte muito importante do projeto. Deve prestar aten√ß√£o a tudo, muito importante n√£o copiar e colar diretamente o arquivo sem saber o que faz o qu√™. Na avalia√ß√£o, deve explicar cada comando se o avaliador o pedir.
:::

:::tip[üß† O que √© um script‚ùì]
√â uma sequ√™ncia de comandos armazenados num arquivo que, quando executado, far√° a fun√ß√£o de cada comando.
:::

#### Arquitetura

Para ver a arquitetura do SO e a sua vers√£o do kernel utilizaremos o comando `uname -a` *("-a" == "--all" )* que basicamente imprimir√° toda a informa√ß√£o excepto se o tipo de processador for desconhecido ou a plataforma de hardware.

![soinfo](./img/soinfo.png)

#### N√∫cleos f√≠sicos
Para exibir o n√∫mero de n√∫cleos f√≠sicos, faremos uso do arquivo `/proc/cpuinfo` que fornece informa√ß√µes sobre o processador: o seu tipo, marca, modelo, desempenho, etc. Utilizaremos o comando `grep "physical id" /proc/cpuinfo | wc -l` com o comando grep procuraremos dentro do ficheiro "physical id" e com wc -l contaremos as linhas do resultado do grep. Fazemo-lo porque a forma de quantificar os n√∫cleos n√£o √© muito comum. Se houver um processador, marcar√° 0 e se houver mais do que um processador, mostrar√° toda a informa√ß√£o do processador separadamente contando os processadores usando nota√ß√£o zero. Desta forma, contamos simplesmente o n√∫mero de linhas, pois √© mais conveniente quantific√°-lo desta forma.

![nucleosphys](./img/physid.png)

#### N√∫cleos virtuais
Mostrar o n√∫mero de n√∫cleos virtuais √© muito semelhante ao anterior. Utilizaremos novamente o arquivo `/proc/cpuinfo`, mas, neste caso, utilizaremos o comando `grep processor /proc/cpuinfo | wc -l`. A utiliza√ß√£o √© praticamente a mesma que a anterior, excepto que em vez de contarmos as linhas f√≠sicas de id, iremos contar as linhas do processador. Fazemos desta forma pela mesma raz√£o que anteriormente, a forma de quantificar marcas 0 se houver um processador.

![virtualnucl](./img/virtualnucl.png)

#### Mem√≥ria RAM
Para exibir a mem√≥ria da vm utilizaremos o comando free para ver num relance informa√ß√µes sobre a vm, a pe√ßa usada, free, reservada para outros recursos, etc. Para mais informa√ß√µes sobre o comando utilizaremos free --help. Utilizaremos `free --mega` porque no subject existe essa unidade de medida (Megabyte). √â importante usar --mega e n√£o -m. Com -m referir-nos-emos √† unidade de medida Mebibyte e esta n√£o √© a especificada no subject.

![freemega](./img/freemega.png)

Uma vez executado este comando, devemos filtrar a nossa pesquisa uma vez que n√£o precisamos de toda a informa√ß√£o que nos d√°, a primeira coisa que devemos mostrar √© a mem√≥ria utilizada, para isso utilizaremos o comando awk, o que este comando faz √© processar dados com base em arquivo de texto, ou seja, podemos utilizar os dados que nos interessam no arquivo X. O que faremos √© comparar se a primeira palavra de uma linha for igual a "Mem:" imprimiremos a terceira palavra dessa linha que ser√° a mem√≥ria utilizada. O comando completo em conjunto seria `free --mega | awk '$1 == "Mem:" {print $3}'`. No script, o valor de retorno deste comando ser√° atribu√≠do a uma vari√°vel que ser√° concatenada com outras vari√°veis, para que tudo se mantenha igual ao especificado no subject.

![memram](./img/memram.png)

Para obter a mem√≥ria total, o comando √© praticamente o mesmo que o anterior, a √∫nica altera√ß√£o √© que em vez de imprimir a terceira palavra da linha, queremos a segunda palavra `free --mega | awk '$1 == "Mem:" {print $2}'`.

![memramf](./img/memramf.png)

Por √∫ltimo, precisamos calcular a % de mem√≥ria utilizada. O comando √© novamente semelhante aos anteriores, a √∫nica modifica√ß√£o que faremos est√° na parte da impress√£o. Como a opera√ß√£o para obter a porcentagem n√£o √© exata, pode dar-nos muitas casas decimais e no subject apenas 2 s√£o mostradas, pelo que faremos o mesmo, por isso utilizamos %.2f para que apenas 2 casas decimais sejam mostradas. Outra coisa que talvez n√£o saiba √© que na impress√£o para mostrar um % tem de colocar %%. O comando completo `free --mega | awk '$1 == "Mem:" {printf("(%.2f%%%%)\n", $3/$2*100)}'`.

![memperc](./img/memperc.png)

#### Mem√≥ria em disco

PPara ver a mem√≥ria de disco ocupada e dispon√≠vel, utilizaremos o comando `df` que significa "sistema de arquivo de disco", que √© utilizado para obter uma vis√£o completa da utiliza√ß√£o do espa√ßo em disco. Como o subject indica que a mem√≥ria utilizada √© mostrada em MB, utilizaremos a bandeira -m. Em seguida, iremos grep para mostrar apenas linhas contendo "/dev/" e depois grep novamente com a bandeira -v para excluir linhas contendo "/boot". Finalmente utilizaremos o comando awk e acrescentaremos o valor da terceira palavra de cada linha para imprimir o resultado final da soma. O comando completo √© o seguinte: `df -m | grep "/dev/" | grep -v "/boot" | awk '{memory_use += $3} END {print memory_use}'`.

![diskspace](./img/diskspace.png)

Para obter o espa√ßo total, utilizaremos um comando muito semelhante. As √∫nicas diferen√ßas ser√£o que os valores que adicionaremos ser√£o os $2 em vez de $3 e a outra diferen√ßa √© que no subject aparece o tamanho total em Gb, pelo que, como resultado da soma nos d√° o n√∫mero em Mb devemos transform√°-lo em Gb, pois deve dividir-se o n√∫mero entre 1024 e retirar as casas decimais.
`df -m | grep "/dev/" | grep -v "/boot" | awk '{memory_use += $2} END {print memory_use}'`

![diskspace2](./img/diskspace2.png)

Finalmente, precisamos de mostrar uma porcentagem da mem√≥ria utilizada. Para tal, mais uma vez, utilizaremos um comando muito semelhante aos dois anteriores. A √∫nica coisa que vamos mudar √© que vamos combinar os dois comandos anteriores para termos duas vari√°veis, uma representando a mem√≥ria utilizada e a outra o total. Uma vez feito isto, faremos uma opera√ß√£o para obter a porcentagem `use/total*100` e o resultado desta opera√ß√£o ser√° impresso como aparece no subject, entre par√™nteses e com o s√≠mbolo % no final. O comando final √©: `df -m | grep "/dev/" | grep -v "/boot" | awk '{use += $3} {total += $2} END {printf("%d%%"), use/total*100}`.

![diskusef](./img/diskusef.png)

#### Porcentagem de utiliza√ß√£o de CPU

Para ver a porcentagem de utiliza√ß√£o de CPU faremos uso do comando `vmstat` que mostra as estat√≠sticas do sistema, permitindo-nos obter um detalhe geral dos processos, utiliza√ß√£o de mem√≥ria, actividade de CPU, estado do sistema, etc. Poderemos colocar se n√£o houver op√ß√£o mas no meu caso colocarei um intervalo de segundos de 1 a 4. Tamb√©m faremos uso do comando `tail -1` que nos permitir√° produzir apenas a √∫ltima linha, depois dos 4 gerados apenas a √∫ltima ser√° impressa. Finalmente, imprimiremos apenas a palavra 15 que √© a utiliza√ß√£o de mem√≥ria dispon√≠vel. O comando completo √© o seguinte: `vmstat 1 4 | tail -1 | awk '{print $15}'`. O resultado deste comando √© apenas uma parte do resultado final, uma vez que ainda √© necess√°rio fazer algumas opera√ß√µes para o obter corretamente. O que ter√≠amos de fazer √© subtrair de 100 o montante devolvido pelo nosso comando, o resultado desta opera√ß√£o ser√° impresso com uma casa decimal e uma % no final e a opera√ß√£o ser√° feita

![cpu](./img/cpu.png)

#### √öltimo rein√≠cio

Para ver a data e hora do nosso √∫ltimo reboot utilizaremos o comando `who` com a bandeira -b porque com esta flag veremos a hora do √∫ltimo boot do sistema. Como j√° aconteceu antes, mostra-nos mais informa√ß√£o do que queremos, por isso filtraremos e mostraremos apenas aquilo em que estamos interessados, para o fazer utilizaremos o comando awk e compararemos se a primeira palavra de uma linha for "sistema" a terceira palavra dessa linha, um espa√ßo e a quarta palavra ser√° impressa no ecr√£. Todo o comando seria o seguinte: `who -b | awk '$1 == "system" {print $3 " " $4}'`.

![who](./img/who.png)

#### Utiliza√ß√£o de LVM
Para verificar se o LVM est√° ou n√£o ativo, utilizaremos o comando `lsblk`, que nos mostra informa√ß√£o de todos os dispositivos de bloco (discos r√≠gidos, SSD, mem√≥rias, etc.) entre toda a informa√ß√£o que nos fornece, podemos ver o lvm no tipo de gestor. Basicamente a condi√ß√£o que procuramos √© contar o n√∫mero de linhas onde "lvm" aparece e se houver mais de 0 imprimimos Sim, se houver 0 imprimimos N√£o. O comando completo seria: `if [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]; then echo yes; else echo no; fi`.

![lvm](./img/lvm.png)

#### Conex√µes TCP
Para olhar para o n√∫mero de liga√ß√µes TCP estabelecidas. Utilizaremos o comando `ss` para substituir o comando obsoleto netstat. Filtrar com a flag `-ta` para que apenas as liga√ß√µes TCP sejam mostradas. Finalmente, vamos ver quais s√£o as que est√£o estabelecidas, uma vez que tamb√©m existem as que s√≥ ouvem, e fechar com wc -l para contar o n√∫mero de linhas. O comando √©: `ss -ta | grep ESTAB | wc -l`.

![tcp](./img/tcp.png)

#### N√∫mero de utilizadores
Utilizaremos o comando users que nos mostrar√° o nome dos utilizadores, sabendo isto, configuraremos wc -w para contar o n√∫mero de palavras na sa√≠da do comando. Todo o comando tem o seguinte: `users | wc -w`.

![users](./img/users.png)

#### Endere√ßo IP e MAC
Para obter o endere√ßo do host utilizaremos o comando Hostname -I e para obter o endere√ßo MAC utilizaremos o comando `ip link` que √© utilizado para mostrar ou modificar as interfaces de rede. Como mais do que uma interface, aparecem os IP's, etc. Utilizaremos o comando grep para procurar o que queremos imprimir no ecr√£ apenas o que nos √© pedido. Utilizaremos para mostrar apenas o endere√ßo MAC: `ip link | grep "link/ether" | awk '{print $2}'`

![MAC](./img/mac.png)

#### N√∫mero de comandos executados com sudo
Para obter o n√∫mero de comandos que s√£o executados com o sudo, utilizaremos o comando `journalctl`, que √© uma ferramenta respons√°vel pela recolha e gest√£o dos registos do sistema. Depois colocamos _COMM=sudo para filtrar as entradas, especificando o seu caminho. No nosso caso, colocamos _COMM, uma vez que se refere a um script execut√°vel. Depois de filtrarmos a pesquisa e s√≥ aparecerem os logs do sudo, ainda temos de filtrar um pouco mais porque quando se faz o log in ou log out como root tamb√©m aparece no log, ent√£o para terminar a filtragem colocaremos um grep COMMAND e assim s√≥ aparecem as linhas de comando. Finalmente, colocaremos wc -l para que as linhas sejam listadas. O comando completo √© o seguinte: `journalctl _COMM=sudo | grep COMMAND | wc -l`). Para verificar se funciona correctamente, podemos executar o comando no terminal, colocar um comando que inclui o sudo e executar novamente o comando e este deve aumentar o n√∫mero de execu√ß√µes de sudo.

![sudoCount](./img/sudocount.png)

#### Resultado total do script

```javascript
#!/bin/bash

# ARCH
arch=$(uname -a)

# CPU PHYSICAL
cpuf=$(grep "physical id" /proc/cpuinfo | wc -l)

# CPU VIRTUAL
cpuv=$(grep "processor" /proc/cpuinfo | wc -l)

# RAM
ram_total=$(free --mega | awk '$1 == "Mem:" {print $2}')
ram_use=$(free --mega | awk '$1 == "Mem:" {print $3}')
ram_percent=$(free --mega | awk '$1 == "Mem:" {printf("%.2f"), $3/$2*100}')

# DISK
disk_total=$(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_t += $2} END {printf ("%.1fGb\n"), disk_t/1024}')
disk_use=$(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_u += $3} END {print disk_u}')
disk_percent=$(df -m | grep "/dev/" | grep -v "/boot" | awk '{disk_u += $3} {disk_t+= $2} END {printf("%d"), disk_u/disk_t*100}')

# CPU LOAD
cpul=$(vmstat 1 2 | tail -1 | awk '{printf $15}')
cpu_op=$(expr 100 - $cpul)
cpu_fin=$(printf "%.1f" $cpu_op)

# LAST BOOT
lb=$(who -b | awk '$1 == "system" {print $3 " " $4}')

# LVM USE
lvmu=$(if [ $(lsblk | grep "lvm" | wc -l) -gt 0 ]; then echo yes; else echo no; fi)

# TCP
tcpc=$(ss -ta | grep ESTAB | wc -l)

# USER LOG
ulog=$(users | wc -w)

# NETWORK
ip=$(hostname -I)
mac=$(ip link | grep "link/ether" | awk '{print $2}')

# SUDO
cmnd=$(journalctl _COMM=sudo | grep COMMAND | wc -l)

wall -t tty1 "	Architecture: $arch
	CPU physical: $cpuf
	vCPU: $cpuv
	Memory Usage: $ram_use/${ram_total}MB ($ram_percent%)
	Disk Usage: $disk_use/${disk_total} ($disk_percent%)
	CPU load: $cpu_fin%
	Last boot: $lb
	LVM use: $lvmu
	Connections TCP: $tcpc ESTABLISHED
	User log: $ulog
	Network: IP $ip ($mac)
	Sudo: $cmnd cmd"
```

Deve exibir algo assim:
Note que estou no root

![script](./img/script.png)